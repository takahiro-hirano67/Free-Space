This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: **/*
- Files matching these patterns are excluded: additional-folder, **/*.log, .gitignore, document/, frontend/eslint.config.mjs, frontend/next.config.ts, frontend/postcss.config.mjs, frontend/tsconfig.json, frontend/types/api.ts, frontend/tailwind.config.js, repomix.config.json
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

</file_summary>

<user_provided_header>
アプリのコードベース
</user_provided_header>

<directory_structure>
backend/.python-version
backend/main.py
backend/pyproject.toml
frontend/.gitignore
frontend/app/favicon.ico
frontend/app/globals.css
frontend/app/home/HomeClient.tsx
frontend/app/home/maps/map-basic/MapView.tsx
frontend/app/home/maps/map-basic/MapWrapper.tsx
frontend/app/home/maps/map-basic/page.tsx
frontend/app/home/maps/map-floor/MapView.tsx
frontend/app/home/maps/map-floor/MapWrapper.tsx
frontend/app/home/maps/map-floor/page.tsx
frontend/app/home/maps/map-pin/DirectionPad.tsx
frontend/app/home/maps/map-pin/MapView.tsx
frontend/app/home/maps/map-pin/MapWrapper.tsx
frontend/app/home/maps/map-pin/page.tsx
frontend/app/home/maps/map-zoom/MapView.tsx
frontend/app/home/maps/map-zoom/MapWrapper.tsx
frontend/app/home/maps/map-zoom/page.tsx
frontend/app/home/page.tsx
frontend/app/layout.tsx
frontend/app/page.tsx
frontend/components/layout/header.tsx
frontend/components/markdown/markdown_style.css
frontend/components/markdown/MarkdownViewer.tsx
frontend/components/markdown/Mermaid.tsx
frontend/components/ui/CopyButton.tsx
frontend/hooks/useMarkdown.ts
frontend/package.json
frontend/public/docs/maps/React-Leaflet-Guide.md
frontend/public/maps/icons/soccer_ball.png
frontend/public/maps/map/campus_map_ziyuu.png
frontend/public/maps/map/campus_map.jpg
frontend/public/maps/map/ziyuu_floor_1.png
frontend/public/maps/map/ziyuu_floor_2.png
frontend/public/maps/map/ziyuu_floor_3.png
frontend/public/maps/map/ziyuu_floor_4.png
frontend/public/mascot/aorun_feel_down.png
frontend/public/mascot/aorun_feel_up.png
frontend/public/mascot/aorun_normal.png
frontend/public/mascot/aorun_question.png
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.python-version">
3.13
</file>

<file path="backend/main.py">
# 現時点でbackendは空の状態（将来的な拡張に備えるため）

def main():
    print("Hello from backend!")


if __name__ == "__main__":
    main()
</file>

<file path="backend/pyproject.toml">
[project]
name = "backend"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.13"
dependencies = []
</file>

<file path="frontend/.gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="frontend/app/globals.css">
/* Free-Space/frontend/app/globals.css */

@import "tailwindcss";

:root {
    --background: #ffffff;
    --foreground: #171717;
}

@theme inline {
    --color-background: var(--background);
    --color-foreground: var(--foreground);
    --font-sans: var(--font-geist-sans);
    --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
    :root {
        --background: #0a0a0a;
        --foreground: #ededed;
    }
}

body {
    background: var(--background);
    color: var(--foreground);
    font-family: Arial, Helvetica, sans-serif;
}
</file>

<file path="frontend/app/home/HomeClient.tsx">
// Free-Space/frontend/app/home/HomeClient.tsx

"use client";

import MarkdownViewer from "@/components/markdown/MarkdownViewer";
import { ChevronDown, ChevronRight, Github, Map, MapPin, ZoomIn, TriangleRight } from "lucide-react";
import Link from "next/link";
import { useState } from "react";

// サーバーから受け取るデータの型定義
type Props = {
    readmeContent: string;
};

export default function HomeClient({ readmeContent }: Props) {
    const [displayReadme, setDisplayReadme] = useState<boolean>(false);

    // ============================================================
    // カテゴリリンク定義
    // ============================================================

    const categories = {
        maps: {
            title: "地図（React-Leaflet）",
            color: "bg-blue-100 text-blue-700",
            links: [
                {
                    icon: Map,
                    label: "基本形",
                    id: "map-basic",
                    url: "/home/maps/map-basic",
                    target: "",
                },
                {
                    icon: MapPin,
                    label: "ピン",
                    id: "map-pin",
                    url: "/home/maps/map-pin",
                    target: "",
                },
                {
                    icon: ZoomIn,
                    label: "ズーム",
                    id: "map-zoom",
                    url: "/home/maps/map-zoom",
                    target: "",
                },
                {
                    icon: TriangleRight,
                    label: "階層",
                    id: "map-floor",
                    url: "/home/maps/map-floor",
                    target: "",
                },
            ],
        },
        external: {
            title: "外部リンク",
            color: "bg-pink-100 text-pink-700",
            links: [
                {
                    icon: Github,
                    label: "リポジトリへのリンク",
                    id: "Repository",
                    url: "https://github.com/takahiro-hirano67/Free-Space.git",
                    target: "_blank",
                },
            ],
        },
    };

    return (
        <div className="flex-1 overflow-y-auto pb-32">
            <div className="max-w-6xl mx-auto">
                {/* カテゴリリンク表示 */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                    {Object.entries(categories).map(([key, category]) => (
                        <div key={key} className="space-y-2">
                            <div
                                className={`inline-block px-3 py-1 rounded-lg text-xs font-semibold mb-3 ${category.color}`}>
                                {category.title}
                            </div>
                            <div className="space-y-1">
                                {category.links.map((link) => (
                                    <Link
                                        key={link.id}
                                        href={link.url}
                                        target={link.target}
                                        rel={
                                            link.target === "_blank"
                                                ? "noopener noreferrer"
                                                : undefined
                                        }
                                        className="w-full flex items-center gap-3 px-4 py-3 text-left bg-white border border-gray-200 rounded-xl hover:border-blue-300 hover:shadow-sm transition-all group">
                                        <div className="w-9 h-9 bg-gray-50 rounded-lg flex items-center justify-center group-hover:bg-blue-50 transition-colors">
                                            <link.icon className="w-5 h-5 text-gray-600 group-hover:text-blue-600 transition-colors" />
                                        </div>
                                        <span className="text-sm font-medium text-gray-700 group-hover:text-blue-600 transition-colors">
                                            {link.label}
                                        </span>
                                        <ChevronRight className="w-4 h-4 text-gray-400 ml-auto opacity-0 group-hover:opacity-100 transition-opacity" />
                                    </Link>
                                ))}
                            </div>
                        </div>
                    ))}
                </div>

                {/* README トグルボタンエリア */}
                <div className="flex flex-col max-w-54 mt-52 mb-6">
                    <button
                        onClick={() => setDisplayReadme(!displayReadme)}
                        className="flex items-center justify-start gap-2 px-5 py-2.5 bg-white border border-gray-200 rounded-full text-sm font-medium text-gray-600 hover:text-blue-600 hover:border-blue-200 hover:shadow-sm transition-all duration-200">
                        {displayReadme ? (
                            <>
                                <ChevronDown className="w-4 h-4" />
                                README.md を閉じる
                            </>
                        ) : (
                            <>
                                <ChevronRight className="w-4 h-4" />
                                README.md を開く
                            </>
                        )}
                    </button>
                </div>

                {/* README表示エリア */}
                {displayReadme && (
                    <div className="bg-white p-6 rounded-xl border border-gray-200 animate-in fade-in slide-in-from-top-4 duration-300">
                        <h2 className="text-xl font-bold mb-4 text-gray-700 flex items-center gap-2">
                            README.md
                        </h2>
                        <hr className="mb-4" />
                        <MarkdownViewer content={readmeContent} />
                    </div>
                )}
            </div>
        </div>
    );
}
</file>

<file path="frontend/app/home/maps/map-basic/MapView.tsx">
// Free-Space/frontend/app/home/maps/map-basic/MapView.tsx

"use client";

import L, { CRS, LatLngBoundsExpression } from "leaflet";
import "leaflet/dist/leaflet.css";
import { useCallback } from "react";
import { AttributionControl, ImageOverlay, MapContainer, Marker } from "react-leaflet";

export default function MapView() {
    // ============================================================
    // 【マップ境界定義】
    // - bounds（境界） は、地図上の矩形の領域を定義するもの。左下と右上の2点の座標で表現される。
    // - Leafletでは実際の地理座標（緯度・経度）を使うが、CRS.Simple を使用しているため、ピクセル座標として扱われる。
    // 緯度 (Latitude) , 経度 (Longitude) ※ 地理座標の伝統的な表記順序
    //  ↓                 ↓
    // Y軸               X軸
    // ============================================================

    // 画像サイズ設定(px)
    const imgHeight: number = 696; // 高さ(Y)
    const imgWidth: number = 1170; // 幅(X)

    // 画像の境界（表示範囲）を定義（bounds = 境界）
    const bounds: LatLngBoundsExpression = [
        [0, 0], // 画像の左下（原点）
        [imgHeight, imgWidth], // 画像の右上（Y: 696, X: 1170）
    ];

    // ============================================================
    // 【マップアイコン定義】
    // ============================================================

    // public 配下の画像を使ってアイコンを定義
    const aorun_icon = L.icon({
        iconUrl: "/mascot/aorun_normal.png",
        iconSize: [64, 64], // アイコンのサイズ
        iconAnchor: [32, 32], // アイコンの判定座標（アイコン画像内のどのピクセル位置かを示す。ピン→先端, 画像→中央）
    });

    // クリックハンドラ（引数）
    const handleMarkerClick = useCallback(
        (place: string) => (): void => {
            alert(`${place}がクリックされました`);
        },
        []
    );

    return (
        <>
            {/* w-full で幅いっぱいにしつつ、高さは「画像の比率」に自動計算させる */}
            <div
                className="w-full border border-gray-200"
                style={{ aspectRatio: `${imgWidth} / ${imgHeight}` }}>
                <MapContainer
                    crs={CRS.Simple} // ピクセル座標系を指定（平面図は地球の曲率を考慮する必要がない）
                    center={[imgHeight / 2, imgWidth / 2]} // マップの中央を指定
                    zoom={0} // 拡大・縮小初期値
                    maxZoom={2} // 拡大段階(0～プラス, 1の時→2倍に拡大)
                    minZoom={0} // 縮小段階(マイナス～0, -1の時→0.5倍に縮小) ※ PCなら0, スマホなら-1が丁度いい?
                    style={{ height: "100%", width: "100%" }} // 明示的に高さと幅を指定
                    maxBounds={bounds} // ユーザーがパン（ドラッグ移動）できる範囲の制限 --> ユーザーは `bounds` で定義された範囲の外にはドラッグできなくなる
                    maxBoundsViscosity={0.6} // 境界に達したときの抵抗の強さ（1.0: 固定, 0.5: 小さい抵抗, 0.0: 抵抗なし）/ 1.0未満 --> 境界を少し越えられるが、手を離すと戻る
                    attributionControl={false} // デフォルトの権利表記をオフ
                >
                    {/* 権利表記の調整（右下・初期挿入なし） */}
                    <AttributionControl position="bottomright" prefix={false} />
                    {/* 表示画像 */}
                    <ImageOverlay url="/maps/map/campus_map.jpg" bounds={bounds} attribution="© Example" />

                    {/* マーカー（中央） */}
                    <Marker
                        position={[imgHeight / 2, imgWidth / 2]} // マップ内の配置座標
                        icon={aorun_icon} // 表示アイコン
                        eventHandlers={{
                            click: handleMarkerClick("中央"),
                        }}
                    />
                </MapContainer>
            </div>
        </>
    );
}

// メモ
// CRS (Coordinate Reference System) = 座標参照系
</file>

<file path="frontend/app/home/maps/map-basic/MapWrapper.tsx">
// Free-Space/frontend/app/home/maps/map-basic/MapWrapper.tsx

"use client";

import MarkdownViewer from "@/components/markdown/MarkdownViewer"; // ドキュメント表示用
import { useMarkdown } from "@/hooks/useMarkdown"; // ドキュメント表示用
import { CopyButton } from "@/components/ui/CopyButton"; // ドキュメントコピー用
import dynamic from "next/dynamic";

// MapView をクライアント側だけで読み込む
const DynamicMapView = dynamic(() => import("./MapView"), {
    ssr: false,
    loading: () => (
        <div
            className="w-full border border-gray-200 flex items-center justify-center"
            style={{ aspectRatio: "1170 / 696" }} // 地図と同じアスペクト比を維持（レイアウトシフト防止）
        >
            <div className="text-center">
                {/* スピナーアニメーションとローディング表記 */}
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto mb-4" />
                <p className="text-gray-600">地図を読み込んでいます...</p>
            </div>
        </div>
    ),
});

// メインコンポーネント
export default function MapWrapper() {
    const { content, loading, error } = useMarkdown("/docs/maps/React-Leaflet-Guide.md"); // ドキュメント表示用

    return (
        <div className="max-w-6xl w-full mx-auto">
            <h2 className="text-2xl font-semibold pb-4">案内図 基本</h2>
            <ul className="pb-2 list-disc list-inside">
                <li>拡大・縮小が可能です。</li>
                <li>ドラッグすることで移動可能です。（パン操作）</li>
                <li>マップの領域外までパン操作すると、抵抗とともに元に戻る挙動をします。</li>
                <li>アイコンをクリックすることで、その場所を表示するalertが出現します。</li>
            </ul>
            {/* マップ */}
            <DynamicMapView />
            {/* ドキュメント表示 */}
            <div className="bg-white mt-32 p-6 rounded-xl border border-gray-200">
                <div className="flex items-center justify-between mb-4">
                    <h2 className="text-xl font-bold text-gray-700">
                        資料
                    </h2>
                    <CopyButton text={content} label="全文をコピー" />
                </div>
                <hr className="mb-4" />
                {loading && <p>Loading...</p>}
                {error && <p>Error: {error.message}</p>}
                {content && <MarkdownViewer content={content} />}
            </div>
        </div>
    );
}
</file>

<file path="frontend/app/home/maps/map-basic/page.tsx">
// Free-Space/frontend/app/home/maps/map-basic/page.tsx

// ※ "use client" は書かない（サーバーコンポーネントのまま）
//    基本的にMapWrapperを編集する

import MapWrapper from "./MapWrapper";

export default function MapPage() {
    return <MapWrapper />;
}
</file>

<file path="frontend/app/home/maps/map-floor/MapView.tsx">
// Free-Space/frontend/app/home/maps/map-floor/MapView.tsx
"use client";

import L, { CRS, LatLngBoundsExpression } from "leaflet";
import "leaflet/dist/leaflet.css";
import { useCallback, useState } from "react";
import { AttributionControl, ImageOverlay, MapContainer, Marker } from "react-leaflet";

export default function MapView() {
    // ============================================================
    // 【ステート管理】
    // 現在の階層を管理 (初期値: 1階)
    // ============================================================
    const [currentFloor, setCurrentFloor] = useState<number>(1);

    // 階層リスト定義 (表示順: 上から 4, 3, 2, 1)
    const floors = [4, 3, 2, 1];

    // ============================================================
    // 【マップ境界定義】
    // ============================================================

    // 画像サイズ設定(px)
    // ※ 4枚の画像サイズがすべて同じである前提
    const imgHeight: number = 696;
    const imgWidth: number = 1170;

    // 画像の境界（表示範囲）を定義
    const bounds: LatLngBoundsExpression = [
        [0, 0], // 画像の左下
        [imgHeight, imgWidth], // 画像の右上
    ];

    // ============================================================
    // 【マップアイコン定義】
    // ============================================================

    const aorun_icon = L.icon({
        iconUrl: "/mascot/aorun_normal.png",
        iconSize: [64, 64],
        iconAnchor: [32, 32],
    });

    const handleMarkerClick = useCallback(
        (place: string) => (): void => {
            alert(`${place}がクリックされました`);
        },
        []
    );

    return (
        <>
            {/* 親要素に relative を指定し、内部の絶対配置(ボタン)の基準とする */}
            <div
                className="w-full border border-gray-200 relative group"
                style={{ aspectRatio: `${imgWidth} / ${imgHeight}` }}>
                <MapContainer
                    crs={CRS.Simple}
                    center={[imgHeight / 2, imgWidth / 2]}
                    zoom={0}
                    minZoom={0} // 縮小の限界を0に固定
                    maxZoom={0} // 拡大の限界を0に固定
                    zoomControl={false} // デフォルトのズーム(+/-)ボタンを非表示
                    scrollWheelZoom={false} // マウスホイールでのズームを無効化
                    doubleClickZoom={false} // ダブルクリックでのズームを無効化
                    touchZoom={false} // タッチ操作でのズームを無効化
                    dragging={true} // ドラッグ（パン）移動は許可する
                    style={{ height: "100%", width: "100%", background: "#f9fafb" }} // 背景色を少しグレーにして画像読み込み時を目立たなくする
                    maxBounds={bounds}
                    maxBoundsViscosity={1.0}
                    attributionControl={false}>
                    <AttributionControl position="bottomleft" prefix={false} />

                    {/* 現在の階層 (currentFloor) に応じて画像を切り替え */}
                    {/* ※ テンプレートリテラルでパスを動的に生成（ファイル名に命名規則を持たせると可能） */}
                    <ImageOverlay
                        url={`/maps/map/ziyuu_floor_${currentFloor}.png`}
                        bounds={bounds}
                        attribution="© Free Space Map"
                    />

                    {/* マーカー */}
                    {/* ※ 必要であれば currentFloor === 1 の時だけ表示する等の条件分岐を追加可能 */}
                    <Marker
                        position={[imgHeight / 2, imgWidth / 2]}
                        icon={aorun_icon}
                        eventHandlers={{
                            click: handleMarkerClick(`${currentFloor}階の中央`),
                        }}
                    />
                </MapContainer>

                {/* 階層切り替えボタン (マップの上に重ねる) */}
                <div className="absolute bottom-4 right-4 z-1000 flex flex-col gap-1 bg-white p-1 rounded-lg shadow-md border border-gray-300">
                    {floors.map((floor) => (
                        <button
                            key={floor}
                            onClick={(e) => {
                                // 親要素(Map)へのクリック伝播を防ぐ（マップクリック判定防止）
                                e.stopPropagation();
                                setCurrentFloor(floor);
                            }}
                            className={`
                                w-10 h-10 flex items-center justify-center rounded font-bold transition-colors
                                ${
                                    currentFloor === floor
                                        ? "bg-blue-600 text-white" // 選択中のスタイル
                                        : "bg-white text-gray-700 hover:bg-gray-100" // 非選択時のスタイル
                                }
                            `}>
                            {floor}
                        </button>
                    ))}
                </div>
            </div>
        </>
    );
}
</file>

<file path="frontend/app/home/maps/map-floor/MapWrapper.tsx">
// Free-Space/frontend/app/home/maps/map-floor/MapWrapper.tsx

"use client";

import dynamic from "next/dynamic";

// MapView をクライアント側だけで読み込む
const DynamicMapView = dynamic(() => import("./MapView"), {
    ssr: false,
    loading: () => (
        <div
            className="w-full border border-gray-200 flex items-center justify-center"
            style={{ aspectRatio: "1170 / 696" }} // 地図と同じアスペクト比を維持（レイアウトシフト防止）
        >
            <div className="text-center">
                {/* スピナーアニメーションとローディング表記 */}
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto mb-4" />
                <p className="text-gray-600">地図を読み込んでいます...</p>
            </div>
        </div>
    ),
});

// メインコンポーネント
export default function MapWrapper() {
    return (
        <div className="max-w-6xl w-full mx-auto">
            <h2 className="text-2xl font-semibold pb-4">案内図 階層表現</h2>
            <ul className="pb-2 list-disc list-inside">
                <li>
                    マップ右下の階層ボタンを押すことで、表示する階層を切り替えることができます。
                </li>
                <li>表示する画像のサイズは統一していないと表示が不自然になります。</li>
            </ul>
            {/* マップ */}
            <DynamicMapView />
        </div>
    );
}
</file>

<file path="frontend/app/home/maps/map-floor/page.tsx">
// Free-Space/frontend/app/home/maps/map-floor/page.tsx

// ※ "use client" は書かない（サーバーコンポーネントのまま）
//    基本的にMapWrapperを編集する

import MapWrapper from "./MapWrapper";

export default function MapPage() {
    return <MapWrapper />;
}
</file>

<file path="frontend/app/home/maps/map-pin/DirectionPad.tsx">
// Free-Space/frontend/app/home/maps/map-pin/DirectionPad.tsx

"use client";

type Direction = "up" | "down" | "left" | "right";

type Props = {
    onMove: (direction: Direction) => void;
};

const baseButtonClass =
    "w-12 h-12 rounded-lg bg-blue-500 text-white font-semibold " +
    "hover:bg-blue-600 active:bg-blue-700 transition-colors flex items-center justify-center";

export default function DirectionPad({ onMove }: Props) {
    return (
        <div className="grid grid-cols-3 gap-2">
            {/* 上 */}
            <div />
            <button onClick={() => onMove("up")} className={baseButtonClass}>
                ↑
            </button>
            <div />

            {/* 左・下・右 */}
            <button onClick={() => onMove("left")} className={baseButtonClass}>
                ←
            </button>
            <button onClick={() => onMove("down")} className={baseButtonClass}>
                ↓
            </button>
            <button onClick={() => onMove("right")} className={baseButtonClass}>
                →
            </button>
        </div>
    );
}
</file>

<file path="frontend/app/home/maps/map-pin/MapView.tsx">
// Free-Space/frontend/app/home/maps/map-pin/MapView.tsx

"use client";

import L, { CRS, LatLngBoundsExpression, LeafletMouseEvent } from "leaflet";
import "leaflet/dist/leaflet.css";
import { useCallback, useState } from "react";
import { AttributionControl, ImageOverlay, MapContainer, Marker } from "react-leaflet";
import DirectionPad from "./DirectionPad";

export default function MapView() {
    // ============================================================
    // 【マップ境界定義】
    // ============================================================
    const imgWidth: number = 1170;
    const imgHeight: number = 696;

    // 貼り付ける画像の表示範囲（境界）を定義[Y, X]
    const bounds: LatLngBoundsExpression = [
        [0, 0], // 左下（原点）
        [imgHeight, imgWidth], // 右上（高さ最大, 幅最大）
    ];

    // ============================================================
    // 【マップアイコン定義】
    // ============================================================

    // public 配下の画像を使ってアイコンを定義（基本形）
    const aorun_icon = L.icon({
        iconUrl: "/mascot/aorun_normal.png",
        iconSize: [64, 64], // アイコンのサイズ
        iconAnchor: [32, 32], // アイコンの座標（アイコン画像内のどのピクセル位置かを示す。ピン→先端, 画像→中央）
    });

    // アイコン定義を一元管理（オブジェクト化しておくと楽に利用できる）
    const icons = {
        aorun_feel_up: L.icon({
            iconUrl: "/mascot/aorun_feel_up.png",
            iconSize: [64, 64],
            iconAnchor: [32, 32],
        }),
        aorun_feel_down: L.icon({
            iconUrl: "/mascot/aorun_feel_down.png",
            iconSize: [32, 32],
            iconAnchor: [16, 16],
        }),
        aorun_question: L.icon({
            iconUrl: "/mascot/aorun_question.png",
            iconSize: [64, 64],
            iconAnchor: [32, 32],
        }),
        soccer_ball: L.icon({
            iconUrl: "/maps/icons/soccer_ball.png",
            iconSize: [32, 32],
            iconAnchor: [16, 16],
        }),
    };

    // クリックハンドラ
    const handleMarkerClick = useCallback(
        (place: string) => (): void => {
            alert(`${place}がクリックされました`);
        },
        []
    );

    // ============================================================
    // 【移動アイコン関係】
    // ============================================================

    // 初期位置（中央下）
    const initialPositionX = imgWidth / 2;
    const initialPositionY = 50;

    // 方向入力
    const [selfPosition, setSelfPosition] = useState({
        x: initialPositionX,
        y: initialPositionY,
    });

    const handleMoveMarkerClick = useCallback(
        (e: LeafletMouseEvent) => {
            const { lat, lng } = e.latlng;
            alert(`現在の座標: [Y:${selfPosition.y}, X:${selfPosition.x}]`);
        },
        [selfPosition]
    );

    // 方向ボタン用
    const handleControlButtonClick = (direction: "up" | "down" | "left" | "right") => {
        setSelfPosition((prev) => {
            switch (direction) {
                case "right":
                    return { ...prev, x: prev.x + 10 };
                case "left":
                    return { ...prev, x: prev.x - 10 };
                case "up":
                    return { ...prev, y: prev.y + 10 };
                case "down":
                    return { ...prev, y: prev.y - 10 };
                default:
                    return prev;
            }
        });
    };

    return (
        <div className="w-full h-full flex flex-col">
            {/* Map */}
            <div
                className="w-full border border-gray-200"
                style={{ aspectRatio: `${imgWidth} / ${imgHeight}` }}>
                <MapContainer
                    crs={CRS.Simple} // ピクセル座標系指定
                    center={[imgHeight / 2, imgWidth / 2]} // マップの中央を指定
                    zoom={0} // 拡大・縮小初期値
                    maxZoom={2} // 拡大段階
                    minZoom={0} // 縮小段階
                    style={{ width: "100%", height: "100%" }} // 明示的に高さと幅を指定
                    maxBounds={bounds} // ドラッグ移動範囲制限
                    maxBoundsViscosity={0.6} // 境界に達したときの抵抗の強さ
                    attributionControl={false} // デフォルトの権利表記をオフ
                >
                    {/* 権利表記の調整（右下・初期挿入なし） */}
                    <AttributionControl position="bottomright" prefix={false} />
                    {/* 表示画像 */}
                    <ImageOverlay url="/maps/map/campus_map.jpg" bounds={bounds} attribution="© Example" />
                    {/* 左下（原点） */}
                    <Marker
                        position={[0, 0]}
                        icon={icons.aorun_feel_up}
                        eventHandlers={{
                            click: handleMarkerClick("左下のあおるん"),
                        }}
                    />
                    {/* 左上 */}
                    <Marker
                        position={[imgHeight, 0]}
                        icon={icons.aorun_question}
                        eventHandlers={{
                            click: handleMarkerClick("左上のあおるん"),
                        }}
                    />
                    {/* 中央 */}
                    <Marker
                        position={[imgHeight / 2, imgWidth / 2]}
                        icon={aorun_icon}
                        // イベントハンドラ登録（クリックなど）
                        eventHandlers={{
                            click: handleMarkerClick("中央のあおるん"),
                        }}
                    />
                    {/* 右下 */}
                    <Marker
                        position={[0, imgWidth]}
                        icon={icons.aorun_question}
                        eventHandlers={{
                            click: handleMarkerClick("右下のあおるん"),
                        }}
                    />
                    {/* 右上 */}
                    <Marker
                        position={[imgHeight, imgWidth]}
                        icon={icons.aorun_feel_up}
                        eventHandlers={{
                            click: handleMarkerClick("右上のあおるん"),
                        }}
                    />
                    {/* 池の中 */}
                    <Marker
                        position={[375, 260]}
                        icon={icons.aorun_feel_down}
                        eventHandlers={{
                            click: handleMarkerClick("池の中のあおるん"),
                        }}
                    />
                    {/* サッカー場 */}
                    <Marker
                        position={[430, 775]}
                        icon={icons.soccer_ball}
                        eventHandlers={{
                            click: handleMarkerClick("サッカー場"),
                        }}
                    />
                    {/* 中央下（移動するあおるん） */}
                    <Marker
                        position={[selfPosition.y, selfPosition.x]}
                        icon={aorun_icon}
                        eventHandlers={{
                            click: handleMoveMarkerClick,
                        }}
                    />
                </MapContainer>
            </div>
            {/* コントロール */}
            <div className="flex justify-center py-4">
                <DirectionPad onMove={handleControlButtonClick} />
            </div>
        </div>
    );
}
</file>

<file path="frontend/app/home/maps/map-pin/MapWrapper.tsx">
// Free-Space/frontend/app/home/maps/map-pin/MapWrapper.tsx

"use client";

import dynamic from "next/dynamic";

// MapView をクライアント側だけで読み込む
const DynamicMapView = dynamic(() => import("./MapView"), {
    ssr: false,
    loading: () => (
        <div
            className="w-full border border-gray-200 flex items-center justify-center"
            style={{ aspectRatio: "1170 / 696" }} // 地図と同じアスペクト比を維持（レイアウトシフト防止）
        >
            <div className="text-center">
                {/* スピナーアニメーションとローディング表記 */}
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto mb-4" />
                <p className="text-gray-600">地図を読み込んでいます...</p>
            </div>
        </div>
    ),
});

export default function MapWrapper() {
    return (
        <div className="max-w-6xl w-full mx-auto">
            <h2 className="text-2xl font-semibold pb-2">案内図 ピン</h2>
            <ul className="pb-2 list-disc list-inside">
                <li>四隅にピンが存在します。</li>
                <li>下の矢印ボタンを押すことで、中央下にいるあおるんが移動します。</li>
                <li>各アイコンをクリックすることで、その場所を表示するalertが出現します。</li>
            </ul>
            <DynamicMapView />
        </div>
    );
}
</file>

<file path="frontend/app/home/maps/map-pin/page.tsx">
// Free-Space/frontend/app/home/maps/map-pin/page.tsx

// ※ "use client" は書かない（サーバーコンポーネントのまま）
//    基本的にMapWrapperを編集する

import MapWrapper from "./MapWrapper";

export default function MapPage() {
    return <MapWrapper />;
}
</file>

<file path="frontend/app/home/maps/map-zoom/MapView.tsx">
// Free-Space/frontend/app/home/maps/map-zoom/MapView.tsx

"use client";

import L, { CRS, LatLngBoundsExpression } from "leaflet";
import "leaflet/dist/leaflet.css";
import { useCallback, useState } from "react";
import {
    AttributionControl,
    ImageOverlay,
    MapContainer,
    Marker,
    useMapEvents,
} from "react-leaflet";
export default function MapView() {
    // ============================================================
    // 【マップ境界定義】
    // ============================================================
    const imgWidth: number = 1170;
    const imgHeight: number = 696;

    // 貼り付ける画像の表示範囲（境界）を定義[Y, X]
    const bounds: LatLngBoundsExpression = [
        [0, 0], // 左下（原点）
        [imgHeight, imgWidth], // 右上（高さ最大, 幅最大）
    ];

    // ============================================================
    // 【マップアイコン定義】
    // ============================================================

    // アイコン定義を一元管理
    const icons = {
        aorun_normal: L.icon({
            iconUrl: "/mascot/aorun_normal.png",
            iconSize: [64, 64],
            iconAnchor: [32, 32],
        }),
        aorun_feel_up: L.icon({
            iconUrl: "/mascot/aorun_feel_up.png",
            iconSize: [32, 32],
            iconAnchor: [16, 16],
        }),
        aorun_question: L.icon({
            iconUrl: "/mascot/aorun_question.png",
            iconSize: [32, 32],
            iconAnchor: [16, 16],
        }),
        aorun_feel_down: L.icon({
            iconUrl: "/mascot/aorun_feel_down.png",
            iconSize: [32, 32],
            iconAnchor: [16, 16],
        }),
        soccer_ball: L.icon({
            iconUrl: "/maps/icons/soccer_ball.png",
            iconSize: [32, 32],
            iconAnchor: [16, 16],
        }),
    };

    // クリックハンドラ（引数）
    const handleMarkerClick = useCallback(
        (place: string) => (): void => {
            alert(`${place}がクリックされました`);
        },
        []
    );

    // ズームを監視するコンポーネント
    function ZoomWatcher({ onZoomChange }: { onZoomChange: (zoom: number) => void }) {
        useMapEvents({
            zoomend: (e) => {
                onZoomChange(e.target.getZoom());
            },
        });
        return null;
    }

    // ズームを監視するState
    const [zoomLevel, setZoomLevel] = useState(0);

    return (
        <>
            {/* w-full で幅いっぱいにしつつ、高さは「画像の比率」に自動計算させる */}
            <div
                className="w-full border border-gray-200"
                style={{ aspectRatio: `${imgWidth} / ${imgHeight}` }}>
                <MapContainer
                    crs={CRS.Simple} // ピクセル座標系指定
                    center={[imgHeight / 2, imgWidth / 2]} // マップの中央を指定
                    zoom={0} // 拡大・縮小初期値
                    maxZoom={2} // 拡大段階
                    minZoom={0} // 縮小段階
                    style={{ width: "100%", height: "100%" }} // 明示的に高さと幅を指定
                    maxBounds={bounds} // ドラッグ移動範囲制限
                    maxBoundsViscosity={1.0} // 境界に達したときの抵抗の強さ（固定）
                    attributionControl={false} // デフォルトの権利表記をオフ
                >
                    {/* 権利表記の調整（右下・初期挿入なし） */}
                    <AttributionControl position="bottomright" prefix={false} />
                    {/* 表示画像 */}
                    <ImageOverlay url="/campus_map.jpg" bounds={bounds} attribution="© Example" />
                    {/* zoom 監視 */}
                    <ZoomWatcher onZoomChange={setZoomLevel} />
                    {/* 画像切り替え */}
                    {zoomLevel < 1 ? (
                        <>
                            {/* 大学全体 */}
                            <ImageOverlay url="/maps/map/campus_map.jpg" bounds={bounds} />
                            {/* アイコンもズームレベルに合わせて変更可能 */}
                            <Marker
                                position={[375, 260]}
                                icon={icons.aorun_feel_down}
                                eventHandlers={{
                                    click: handleMarkerClick("池の中のあおるん"),
                                }}
                            />
                            {/* サッカー場 */}
                            <Marker
                                position={[430, 775]}
                                icon={icons.soccer_ball}
                                eventHandlers={{
                                    click: handleMarkerClick("サッカー場"),
                                }}
                            />
                        </>
                    ) : (
                        <>
                            {/* 自由ヶ丘キャンパス */}
                            <ImageOverlay url="/maps/map/campus_map_ziyuu.png" bounds={bounds} />
                        </>
                    )}

                    {/* 中央（共通アイコン） */}
                    <Marker
                        position={[imgHeight / 2, imgWidth / 2]}
                        icon={icons.aorun_normal}
                        // イベントハンドラ登録（クリックなど）
                        eventHandlers={{
                            click: handleMarkerClick("中央"),
                        }}
                    />
                </MapContainer>
            </div>
        </>
    );
}
</file>

<file path="frontend/app/home/maps/map-zoom/MapWrapper.tsx">
// Free-Space/frontend/app/home/maps/map-zoom/MapWrapper.tsx

"use client";

import dynamic from "next/dynamic";

// MapView をクライアント側だけで読み込む
const DynamicMapView = dynamic(() => import("./MapView"), {
    ssr: false,
    loading: () => (
        <div
            className="w-full border border-gray-200 flex items-center justify-center"
            style={{ aspectRatio: "1170 / 696" }} // 地図と同じアスペクト比を維持（レイアウトシフト防止）
        >
            <div className="text-center">
                {/* スピナーアニメーションとローディング表記 */}
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900 mx-auto mb-4" />
                <p className="text-gray-600">地図を読み込んでいます...</p>
            </div>
        </div>
    ),
});

export default function MapWrapper() {
    return (
        <div className="max-w-6xl w-full mx-auto">
            <h2 className="text-2xl font-semibold pb-4">案内図 ズーム</h2>
            <DynamicMapView />
        </div>
    );
}
</file>

<file path="frontend/app/home/maps/map-zoom/page.tsx">
// Free-Space/frontend/app/home/maps/map-zoom/page.tsx

// ※ "use client" は書かない（サーバーコンポーネントのまま）
//    基本的にMapWrapperを編集する

import MapWrapper from "./MapWrapper";

export default function MapPage() {
    return <MapWrapper />;
}
</file>

<file path="frontend/app/home/page.tsx">
// Free-Space/frontend/app/home/page.tsx

import fs from "fs";
import path from "path";
import HomeClient from "./HomeClient";

export default function Home() {
    // サーバー側でファイルを読み込む
    const filePath = path.join(process.cwd(), "../README.md");
    let content = "";

    try {
        content = fs.readFileSync(filePath, "utf8");
    } catch (err) {
        console.error(err);
        content = "# Error\nREADME.mdが見つかりませんでした。";
    }

    // クライアントコンポーネントにデータを渡して表示
    return <HomeClient readmeContent={content} />;
}
</file>

<file path="frontend/app/layout.tsx">
// Free-Space/frontend/app/layout.tsx

import { Header } from "@/components/layout/header";
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
    variable: "--font-geist-sans",
    subsets: ["latin"],
});

const geistMono = Geist_Mono({
    variable: "--font-geist-mono",
    subsets: ["latin"],
});

export const metadata: Metadata = {
    title: "Free Space",
    description: "Free Hills Lab 2年グループで共有するリポジトリ",
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="ja">
            <body
                className={`${geistSans.variable} ${geistMono.variable} antialiased`}
                suppressHydrationWarning={true}>
                <div className="flex flex-col h-screen">
                    <Header />
                    <main className="flex-1 flex flex-col overflow-x-hidden  overflow-y-scroll relative px-8 py-8 min-w-0">
                        {children}
                    </main>
                </div>
            </body>
        </html>
    );
}
</file>

<file path="frontend/app/page.tsx">
// Free-Space/frontend/app/page.tsx

import { redirect } from "next/navigation";

// リダイレクト専用ページ
export default function Page() {
    redirect("/home");
}
</file>

<file path="frontend/components/layout/header.tsx">
// Free-Space/frontend/components/layout/header.tsx

"use client";

import { Play } from "lucide-react";
import Link from "next/link";

export const Header = () => {
    return (
        <header
            className="flex items-center justify-between bg-white/80 backdrop-blur-md border-b border-gray-200/70 shadow-2xs z-50 transition-all duration-300"
            style={{ height: "52px" }}>
            <div className="flex items-center gap-2">
                {/* ロゴ部分 */}
                <Link href="/home" className="flex items-center gap-2 ml-2">
                    <div className="w-7 h-7 bg-linear-to-br from-blue-500 to-purple-600 rounded-lg flex items-center justify-center">
                        <Play className="w-4 h-4 text-white" />
                    </div>
                    <span className="font-semibold text-gray-600">FreeHillsLab / FreeSpace</span>
                </Link>
                {/* ホームに戻るボタン */}
                <Link
                    href="/home"
                    className="group flex items-center gap-1.5 mx-2 px-3 py-1.5 rounded-full 
                    bg-gray-50 border border-gray-200
                    hover:bg-white hover:border-blue-200 hover:shadow-2xs hover:text-blue-600
                    transition-all duration-100 cursor-pointer mr-2">
                    <span className="text-xs font-medium text-gray-600 group-hover:text-blue-600 transition-colors">
                        ホームに戻る
                    </span>
                </Link>
            </div>
        </header>
    );
};
</file>

<file path="frontend/components/markdown/markdown_style.css">
/* Free-Space/frontend/components/markdown/markdown_style.css */

/*
    ============================================================
    Markdownのスタイルを適用するCSS (LLM出力テキスト, メモなど)
    ============================================================
*/

/* 見出し */
.markdown h1 {
    font-size: 1.5rem;
    font-weight: bold;
    margin: 1.75rem 0 1rem;
}
.markdown h2 {
    font-size: 1.25rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h3 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h4 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h5 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
.markdown h6 {
    font-size: 1rem;
    font-weight: bold;
    margin: 1.75rem 0 0.5rem;
}
/* 基本書式 */
.markdown p {
    margin-bottom: 1rem;
}
.markdown hr {
    border-top: 1px solid #c4c7c5;
    margin: 0.5rem 0;
}
/* リスト */
.markdown ul {
    padding-left: 1.6875rem;
    margin: 0.5rem 0 1rem;
}
.markdown ol {
    padding-left: 1.6875rem;
    margin: 0.5rem 0 1rem;
}
.markdown li {
    padding-left: 0.25rem;
    margin-bottom: 0.5rem;
    list-style: inside;
    list-style-position: outside;
}
.markdown ul li p {
    padding-left: 0.025rem;
    margin: 0.5rem 0;
}
/* コードブロック */
.markdown pre,
.markdown code {
    background: #f0f4f9;
    border-radius: 0.5rem;
    padding: 0.5rem;
    font-family: "Fira Mono", "Menlo", "Consolas", monospace;
    font-size: 0.95em;
}
.markdown pre {
    overflow-x: auto;
}
.markdown code {
    padding: 0.2em 0.4em;
}
/* テーブル */
.markdown table {
    border-collapse: collapse;
}
.markdown th {
    padding: 0.5rem;
    font-weight: 700;
    border: 1px solid #d6e3ed;
    background-color: #edf2f7;
}
.markdown td {
    padding: 0.5rem;
    border: 1px solid #d6e3ed;
    background-color: #fff;
}

.citation {
    font-size: 0.75em;
    color: #6b7280; /* gray-500 */
    opacity: 0.65;
    margin-left: 0.25em;
    white-space: nowrap;
    cursor: default;
}

.citation:hover {
    opacity: 1;
    color: #2563eb; /* blue-600 */
}
</file>

<file path="frontend/components/markdown/MarkdownViewer.tsx">
// Free-Space/frontend/components/markdown/MarkdownViewer.tsx

"use client";

import "@/components/markdown/markdown_style.css";
import "katex/dist/katex.min.css"; // 数式用CSS

import { Check, Copy } from "lucide-react"; // アイコン用
import dynamic from "next/dynamic";
import React, { memo, useMemo, useState } from "react";
import ReactMarkdown from "react-markdown"; // Markdownレンダリング

// --- Plugins ---
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"; // コードハイライト
import { vs } from "react-syntax-highlighter/dist/esm/styles/prism"; // VSコード風のスタイル
import rehypeKatex from "rehype-katex"; // 数式描画ライブラリを利用してHTML化
import remarkBreaks from "remark-breaks"; // 改行を<br>として扱う
import remarkGfm from "remark-gfm"; // GitHub Flavored Markdown (GFM) の記法を適用
import { remarkAlert } from "remark-github-blockquote-alert"; // GitHubスタイルの警告表示適用
import remarkMath from "remark-math"; // 数式記法の認識（$E=mc^2$ や $$...$$など）

// Mermaidコンポーネントを動的インポート（SSR無効化・Loading表示付き）
// これにより、Mermaidが含まれないページでは巨大なライブラリが読み込まれない
const MermaidPreview = dynamic(() => import("./Mermaid"), {
    ssr: false,
    loading: () => <div className="p-4 text-gray-400 animate-pulse">Loading Diagram...</div>,
});

// ============================================================
// テキスト前処理関数
// ============================================================

const preprocessContent = (content: string) => {
    if (!content) return "";

    let processed = content;

    // 1. MathDelimiters normalization
    // Doclingなどが出力する \[ ... \] や \( ... \) を $$...$$ や $...$ に変換
    processed = processed.replace(/\\\[([\s\S]*?)\\\]/g, "$$$$$1$$$$");
    processed = processed.replace(/\\\(([\s\S]*?)\\\)/g, "$$$1$$");

    // 2. OCR Typos Fix
    // Docling特有の "M u t i { H e a d }" を "MultiHead" に修正
    if (processed.includes("M u t i { H e a d }")) {
        processed = processed.replace(/M u t i \{ H e a d \}/g, "\\text{MultiHead}");
    }

    // 3. KaTeX Aligned Fix
    // 数式内に '&' (整列) があり、かつ環境指定(\begin)がない場合、
    // KaTeXがエラーになるため、自動的に aligned 環境で囲む
    processed = processed.replace(/\$\$([\s\S]*?)\$\$/g, (match, equation) => {
        // 既に環境指定(\begin)がある場合は何もしない
        if (equation.includes("\\begin")) return match;

        // '&' (整列タブ) が含まれている場合、補正対象とする
        if (equation.includes("&")) {
            // $$ の内側に改行を入れ、aligned環境で囲むことで
            // remark-math にブロック数式として認識させ、かつ整列を有効にする
            return `$$\n\\begin{aligned}\n${equation}\n\\end{aligned}\n$$`;
        }

        return match;
    });

    // 4. Code Block normalization
    // コードブロックの ``` の直前に改行がないと正しくパースされない場合への対処
    processed = processed.replace(/([^\n])```/g, "$1\n```");

    return processed;
};

// ============================================================
// メインコンポーネント
// ============================================================

interface MarkdownViewerProps {
    content: string;
    className?: string;
}

const MarkdownViewer: React.FC<MarkdownViewerProps> = ({ content, className }) => {
    // メモ化して前処理を実行
    const processedContent = useMemo(() => preprocessContent(content), [content]);

    return (
        <div className={`markdown ${className || ""}`}>
            <ReactMarkdown
                remarkPlugins={[remarkGfm, remarkBreaks, remarkMath, remarkAlert]}
                rehypePlugins={[rehypeKatex]}
                components={{
                    // pタグをdivタグに置き換えて、Hydrationエラーを回避（pタグの中にdiv(コードブロック)が入るのを防ぐため）
                    p: ({ children }) => <div className="mb-4 leading-relaxed">{children}</div>,

                    // preタグは、中のcodeタグ(CodeBlock)がスタイルを持つため、ラッパーを外す
                    pre: ({ children }) => <>{children}</>,

                    // codeタグをカスタムコンポーネントに置き換え
                    code: CodeBlock,

                    // --- リンク制御（外部リンクを別タブで開く） ---
                    a: ({ node, ...props }) => (
                        <a
                            {...props}
                            target="_blank"
                            rel="noopener noreferrer"
                            className="text-blue-600 hover:underline cursor-pointer"
                        />
                    ),
                }}>
                {processedContent}
            </ReactMarkdown>
        </div>
    );
};
// 【メモ化して、contentが変わった時だけ再レンダリングする】
// ストリーミング時は頻繁に更新されるが、ReactのDiff検知により
// 変更部分以外の再描画コストを抑えらる。
export default memo(MarkdownViewer, (prev, next) => prev.content === next.content);

// -----------------------------------------------------------------------------
// コードブロック用コンポーネント（状態管理のために分離）
// -----------------------------------------------------------------------------
const CodeBlock = ({ node, inline, className, children, ...props }: any) => {
    const match = /language-(\w+)/.exec(className || "");
    const lang = match ? match[1] : "";
    const codeString = String(children).replace(/\n$/, "");
    const [isCopied, setIsCopied] = useState(false);

    // 【メモ】
    // react-markdown v9+ では inline プロパティが渡されないため、独自に判定。
    // 言語指定(match)がなく、かつコード文字列に改行(\n)が含まれていない場合をインラインとみなす。
    const isInline = inline ?? (!match && !codeString.includes("\n"));

    // 1. インラインコードの場合
    if (isInline) {
        return (
            <code
                className="bg-gray-100 text-gray-800 px-1.5 py-0.5 rounded text-sm font-mono mx-0.5 break-all"
                {...props}>
                {children}
            </code>
        );
    }

    // 2. Mermaidの場合
    if (lang === "mermaid") {
        return <MermaidPreview code={codeString} />;
    }

    // 共通のコピー処理
    const handleCopy = async () => {
        await navigator.clipboard.writeText(codeString);
        setIsCopied(true);
        setTimeout(() => setIsCopied(false), 2000);
    };

    // 3. シンタックスハイライト（ヘッダー付きブロック）
    if (match) {
        return (
            <div className="my-4 rounded-lg border border-gray-200 overflow-hidden bg-gray-50">
                {/* ヘッダー部分 */}
                <div className="flex items-center justify-between px-3 py-1.5 bg-gray-100 border-b border-gray-200">
                    <span className="text-xs font-medium text-gray-600 select-none">{lang}</span>
                    <button
                        onClick={handleCopy}
                        className="flex items-center gap-1.5 text-xs text-gray-500 hover:text-blue-600 transition-colors"
                        title="コードをクリップボードにコピー">
                        {isCopied ? (
                            <>
                                <Check size={14} className="text-green-600" />
                                <span className="text-green-600 font-medium">Copied!</span>
                            </>
                        ) : (
                            <>
                                <Copy size={14} />
                                <span>Copy</span>
                            </>
                        )}
                    </button>
                </div>

                {/* コード本文 */}
                <SyntaxHighlighter
                    {...props}
                    style={vs}
                    language={lang}
                    PreTag="div"
                    customStyle={{
                        margin: 0,
                        padding: "1rem",
                        backgroundColor: "transparent",
                        border: "none",
                    }}
                    codeTagProps={{
                        style: {
                            backgroundColor: "transparent",
                            padding: 0, // CSS側のパディングを打ち消す
                        },
                    }}>
                    {codeString}
                </SyntaxHighlighter>
            </div>
        );
    }

    // 4. 言語指定なしのブロックコード（フォールバック）
    // ここに来るのは「言語指定はないが、複数行ある」場合
    return (
        <pre className="p-4 my-4 rounded-lg bg-gray-100 overflow-auto border border-gray-200 text-sm font-mono">
            <code className={className} {...props}>
                {children}
            </code>
        </pre>
    );
};
</file>

<file path="frontend/components/markdown/Mermaid.tsx">
// Free-Space/frontend/components/markdown/Mermaid.tsx

"use client";

import { Check, Download } from "lucide-react"; // アイコン用
import mermaid from "mermaid";
import { useEffect, useRef, useState } from "react";

// mermaidの初期設定
mermaid.initialize({
    startOnLoad: false,
    theme: "default",
    securityLevel: "loose",
    fontFamily: "sans-serif",
    flowchart: { htmlLabels: false }, // HTMLラベルを無効化 --> ダウンロード時のセキュリティ制限に対応
});

interface MermaidProps {
    code: string;
}

const Mermaid = ({ code }: MermaidProps) => {
    const ref = useRef<HTMLDivElement>(null);
    const [isCopied, setIsCopied] = useState(false);
    const [renderId, setRenderId] = useState(""); // ユニークID用

    // コードが変わるたびにユニークなIDを生成（Mermaidのキャッシュ対策）
    useEffect(() => {
        setRenderId(`mermaid${Math.random().toString(36).substring(2, 9)}`);
    }, [code]);

    useEffect(() => {
        if (ref.current && renderId) {
            // 既存のSVGをクリア
            ref.current.innerHTML = "";

            // 一時的な要素を作成して描画させる
            // mermaid.render(id, text, container?) APIを使用
            mermaid
                .render(renderId, code)
                .then(({ svg }) => {
                    if (ref.current) {
                        ref.current.innerHTML = svg;
                    }
                })
                .catch((e) => {
                    console.error("Mermaid render error:", e);
                    if (ref.current)
                        if (ref.current)
                            ref.current.innerHTML = `<p class="text-red-500 text-sm p-2">Rendering Error: ${e.message}</p>`;
                });
        }
    }, [code, renderId]);

    // 画像としてダウンロードする関数
    const handleDownload = () => {
        if (!ref.current) return;
        const svgElement = ref.current.querySelector("svg");
        if (!svgElement) return;

        // 1. SVGデータを文字列化
        const serializer = new XMLSerializer();
        let svgString = serializer.serializeToString(svgElement);

        // 2. SVGをBase64エンコード
        const svgBase64 =
            "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svgString)));

        // 3. Canvasに描画
        const img = new Image();
        img.onload = () => {
            const canvas = document.createElement("canvas");
            const scale = 2; // 解像度を2倍（高画質化）

            // 【修正ポイント】viewBox属性から正確なサイズとアスペクト比を取得
            let width = 0;
            let height = 0;
            const viewBox = svgElement.getAttribute("viewBox");

            if (viewBox) {
                // viewBox = "min-x min-y width height" の形式
                const parts = viewBox.split(/\s+/).map(parseFloat);
                if (parts.length === 4) {
                    width = parts[2];
                    height = parts[3];
                }
            }

            // フォールバック（viewBoxがない場合）
            if (width === 0 || height === 0) {
                const rect = svgElement.getBoundingClientRect();
                width = rect.width;
                height = rect.height;
            }

            // 正確なアスペクト比でCanvasサイズを設定
            canvas.width = width * scale;
            canvas.height = height * scale;

            const ctx = canvas.getContext("2d");
            if (!ctx) return;

            // 背景を白で塗りつぶす
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 画像を描画（Canvasサイズに合わせてスケーリングされる）
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            try {
                // 4. PNG変換とダウンロード
                const pngUrl = canvas.toDataURL("image/png");
                const downloadLink = document.createElement("a");
                downloadLink.href = pngUrl;
                downloadLink.download = `chart-${new Date().getTime()}.png`;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);

                setIsCopied(true);
                setTimeout(() => setIsCopied(false), 2000);
            } catch (e) {
                console.error("Canvas export failed:", e);
                alert("画像の保存に失敗しました。セキュリティ制限の可能性があります。");
            }
        };

        // 画像ソースにBase64を設定
        img.src = svgBase64;
    };

    return (
        <div className="relative group my-4">
            <div
                className="mermaid flex justify-center py-6 bg-white border border-gray-200 rounded-lg shadow-sm overflow-x-auto"
                ref={ref}
            />
            <div className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity duration-200">
                <button
                    onClick={handleDownload}
                    className="p-1.5 bg-gray-100 hover:bg-white text-gray-500 hover:text-blue-600 rounded border border-gray-200 shadow-sm transition-colors"
                    title="PNG画像として保存">
                    {isCopied ? <Check size={16} /> : <Download size={16} />}
                </button>
            </div>
        </div>
    );
};

export default Mermaid;
</file>

<file path="frontend/components/ui/CopyButton.tsx">
// Free-Space/frontend/components/ui/CopyButton.tsx

"use client";

import { Check, Copy } from "lucide-react";
import { useState } from "react";

// ============================================================
// 生成されたテキストをクリップボードにコピーするボタンコンポーネント
// ============================================================

// 通常サイズ
export const CopyButton = ({
    text,
    className = "",
    label = "コピー",
}: {
    text: string;
    className?: string;
    label?: string;
}) => {
    const [isCopied, setIsCopied] = useState(false);

    const handleCopy = async () => {
        if (!text) return;

        try {
            await navigator.clipboard.writeText(text);
            setIsCopied(true);
            // 2秒後にアイコンを元に戻す
            setTimeout(() => {
                setIsCopied(false);
            }, 2000);
        } catch (err) {
            console.error("Failed to copy text: ", err);
        }
    };

    return (
        <button
            onClick={handleCopy}
            disabled={!text || isCopied}
            className={`flex items-center gap-2 px-3 py-1.5 text-xs font-medium rounded-md border transition-all 
                ${
                    isCopied
                        ? "bg-green-50 text-green-700 border-green-200"
                        : "bg-white text-slate-500 border-slate-200 hover:bg-slate-50 hover:text-slate-700"
                } ${className}`}
            title="クリップボードにコピー">
            {isCopied ? <Check size={14} /> : <Copy size={14} />}
            <span>{isCopied ? "コピー完了" : label}</span>
        </button>
    );
};

// 小さいコピーボタン（法人番号用）
export const SmallCopyButton = ({ text }: { text: string }) => {
    const [copied, setCopied] = useState(false);

    const handleCopy = async () => {
        if (!text) return;
        await navigator.clipboard.writeText(text);
        setCopied(true);
        setTimeout(() => setCopied(false), 1500);
    };

    return (
        <button
            onClick={handleCopy}
            disabled={!text}
            className={`
                inline-flex items-center justify-center
                w-7 h-7 rounded-md border
                transition-all
                ${
                    copied
                        ? "bg-green-50 border-green-200 text-green-600"
                        : "bg-white border-slate-200 text-slate-400 hover:bg-slate-50 hover:text-slate-600"
                }
            `}
            title={copied ? "コピーしました" : "コピー"}>
            {copied ? <Check size={14} /> : <Copy size={14} />}
        </button>
    );
};
</file>

<file path="frontend/hooks/useMarkdown.ts">
// Free-Space/frontend/hooks/useMarkdown.ts

"use client";

import { useEffect, useState } from "react";

// public 配下の markdown ファイルを取得するカスタムフック
export function useMarkdown(path: string) {
    const [content, setContent] = useState<string>("");
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        if (!path) return;

        setLoading(true);
        setError(null);

        fetch(path)
            .then((res) => {
                if (!res.ok) {
                    throw new Error(`Failed to fetch markdown: ${path}`);
                }
                return res.text();
            })
            .then(setContent)
            .catch(setError)
            .finally(() => setLoading(false));
    }, [path]);

    return { content, loading, error };
}
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "leaflet": "^1.9.4",
    "lucide-react": "^0.562.0",
    "mermaid": "^11.12.2",
    "next": "16.1.2",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-leaflet": "^5.0.0",
    "react-markdown": "^10.1.0",
    "react-syntax-highlighter": "^16.1.0",
    "rehype-katex": "^7.0.1",
    "rehype-raw": "^7.0.0",
    "remark-breaks": "^4.0.0",
    "remark-gfm": "^4.0.1",
    "remark-github-blockquote-alert": "^2.0.1",
    "remark-math": "^6.0.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/leaflet": "^1.9.21",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/react-syntax-highlighter": "^15.5.13",
    "eslint": "^9",
    "eslint-config-next": "16.1.2",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}
</file>

<file path="frontend/public/docs/maps/React-Leaflet-Guide.md">
# React-Leaflet 入門ガイド

## React-Leaflet とは

-   **Leaflet**: オープンソースの地図表示 JavaScript ライブラリ
-   **React-Leaflet**: Leaflet を React で使いやすくしたラッパーライブラリ
-   **特徴**: 軽量、シンプル、自前の画像を地図として扱える

---

## 1. 基本的なセットアップ

### 1-1. インストール

```bash
npm install leaflet react-leaflet
npm install -D @types/leaflet  # TypeScript使用時
```

### 1-2. ファイル構成例（Next.js App Router の場合）

3 ファイル必要

```
app/
└── map/
    ├── page.tsx         # ルーティング用（サーバーコンポーネント）
    ├── MapWrapper.tsx   # dynamic importの境界
    └── MapView.tsx      # Leaflet本体
```

---

## 2. Next.js での重要な注意点

### 2-1. なぜ特殊な構成が必要なのか

**問題**: Leaflet は `window` や `document` を使うため、サーバー側では動かない

（DOM を直接操作している）

```typescript
// ❌ これだけではエラーになる
import { MapContainer } from "react-leaflet";
```

**エラー例**:

```
ReferenceError: window is not defined
```

### 2-2. 解決策: dynamic import + ssr: false

#### MapWrapper.tsx

```typescript
"use client";

import dynamic from "next/dynamic";

// サーバー側では実行せず、クライアント側でのみロード（マップコンポーネントを動的にインポート）
const DynamicMapView = dynamic(() => import("./MapView"), {
    ssr: false, // ← これが重要
    loading: () => <p>地図を読み込んでいます...</p>,
});

export default function MapWrapper() {
    return (
        <div className="w-full">
            <h2 className="text-2xl font-semibold pb-4">案内図</h2>
            <DynamicMapView /> // ← ここにマップが表示される
        </div>
    );
}
```

#### page.tsx

```typescript
// "use client" は書かない（サーバーコンポーネントのまま）
import MapWrapper from "./MapWrapper";

export default function MapPage() {
    return <MapWrapper />;
}
```

**ポイント**:

-   `ssr: false` でサーバー側の実行をスキップ
-   `loading` でローディング中の表示を設定
-   SEO 用のページ構造はサーバー側で生成される

---

## 3. 主要な概念の解説

### 3-1. CRS（座標参照系）

#### CRS.Simple とは

-   **座標系**: ピクセル座標を直接使う（緯度経度ではない）
-   **用途**: 自前の画像、ゲームマップ、建物平面図など
-   **特徴**: 地球の丸さを考慮しない単純な座標系

```typescript
crs={CRS.Simple}  // ピクセル座標系
```

#### 他の選択肢

```typescript
crs={CRS.EPSG3857}  // Web Mercator（Google Maps等と同じ）
                    // 緯度・経度を使う
                    // 実際の地理データに適している
```

**使い分け**:

-   自前の画像 → `CRS.Simple`
-   実際の地図 → `CRS.EPSG3857`

---

### 3-2. bounds（境界）

#### 基本概念

**bounds** = 地図の矩形領域を定義する 2 点の座標

```typescript
const bounds: LatLngBoundsExpression = [
    [0, 0], // 左下の座標 [Y, X]
    [imgHeight, imgWidth], // 右上の座標 [Y, X]
];
```

#### 視覚的な理解

```
       X軸 幅
    ┌─────────────────┐ (imgHeight, imgWidth)
Y   │                 │
軸  │   [画像領域]     │
    |                 |
高  │                 │
さ  |                 |
    │                 │
    └─────────────────┘
(0, 0)
```

**重要**: Leaflet の座標は `[Y, X]` の順序（`[緯度(Latitude), 経度 (Longitude)]` の伝統的な慣習による）

---

### 3-3. maxBounds と maxBoundsViscosity

#### maxBounds

ユーザーがドラッグできる範囲の制限

```typescript
maxBounds = { bounds }; // 画像の外にドラッグできなくする
```

**効果**:

-   画像の外の空白領域が見えなくなる
-   ユーザーが迷子にならない

#### maxBoundsViscosity

境界に達したときの「抵抗の強さ」

```typescript
maxBoundsViscosity={1.0}  // 完全に固定（壁のように止まる）
maxBoundsViscosity={0.5}  // ある程度越えられるが引き戻される
maxBoundsViscosity={0.0}  // 制限なし（自由に動ける）
```

**体感的な違い**:

-   `1.0`: 壁に当たったような硬い感触
-   `0.5-0.8`: ゴムバンドで引っ張られる柔らかい感触（**推奨**）
-   `0.0`: 制限が実質的に無効

**UX 観点での推奨**:

```typescript
maxBoundsViscosity={0.7}  // 適度なレスポンスで操作感が良い
```

---

### 3-4. zoom（拡大・縮小）

```typescript
zoom={0}       // 初期表示の倍率
maxZoom={2}    // 最大4倍まで拡大可能（2^2 = 4倍）
minZoom={0}    // これ以上縮小できない
```

**zoom の計算**:

-   `zoom = 0` → 等倍
-   `zoom = 1` → 2 倍
-   `zoom = 2` → 4 倍
-   `zoom = -1` → 0.5 倍

---

## 4. 主要コンポーネント

### 4-1. MapContainer

地図全体のコンテナ

```typescript
<MapContainer
    crs={CRS.Simple} // 座標系
    center={[imgHeight / 2, imgWidth / 2]} // 初期表示の中心 [Y, X]
    zoom={0} // 初期ズームレベル
    maxZoom={2} // 最大ズーム（拡大）
    minZoom={0} // 最小ズーム（縮小）
    style={{ height: "100%", width: "100%" }}
    maxBounds={bounds} // ドラッグ範囲制限
    maxBoundsViscosity={0.7} // ドラッグ境界到達時の抵抗
    attributionControl={false} // デフォルトの権利表記をオフ
>
    {/* 子要素... */}
</MapContainer>
```

---

### 4-2. ImageOverlay

画像を地図として表示

```typescript
<ImageOverlay
    url="/campus_map.jpg" // 画像のパス（public配下）
    bounds={bounds} // 画像の表示範囲
    attribution="© Example" // 権利表記
/>
```

---

### 4-3. Marker

地図上にマーカーを配置

```typescript
<Marker
    position={[imgHeight / 2, imgWidth / 2]} // 配置位置 [Y, X]
    icon={customIcon} // カスタムアイコン
    eventHandlers={{
        click: handleMarkerClick("場所名"),
    }}
/>
```

#### カスタムアイコンの定義

```typescript
const customIcon = L.icon({
    iconUrl: "/marker-icon.png", // アイコン画像
    iconSize: [64, 64], // アイコンのサイズ [幅, 高さ]
    iconAnchor: [32, 32], // アイコンの基準点（中心の場合）
});
```

**iconAnchor の理解**:

-   ピンアイコン → `[幅/2, 高さ]` （先端が位置）
-   円形アイコン → `[幅/2, 高さ/2]` （中心が位置）

---

### 4-4. AttributionControl

権利表記の調整（初期状態は扱いにくいため）

```typescript
<AttributionControl
    position="bottomright" // 表示位置
    prefix={false} // "Leaflet"の表記を消す
/>
```

---

## 5. よくある実装パターン

---

### 5-1. レスポンシブ対応

```typescript
<div
    className="w-full border border-gray-200"
    style={{ aspectRatio: `${imgWidth} / ${imgHeight}` }}>
    <MapContainer style={{ height: "100%", width: "100%" }} {...他の属性}>
        {/* ... */}
    </MapContainer>
</div>
```

**ポイント**:

-   `aspectRatio` で画像の縦横比を維持
-   幅は親要素に合わせて自動調整

**備考**:

-   スマホ環境での使用感は要検証

---

## 6. トラブルシューティング

### 6-1. 地図が表示されない

#### 原因 1: CSS が読み込まれていない

```typescript
// MapView.tsx の先頭に必須
import "leaflet/dist/leaflet.css";
```

#### 原因 2: 高さが 0 になっている

```typescript
// MapContainer に明示的に高さを指定
<MapContainer style={{ height: "500px", width: "100%" }} {...}>
```

#### 原因 3: SSR エラー

```
ReferenceError: window is not defined
```

**解決策**: `dynamic` + `ssr: false` を使う（2 章参照）

---

### 6-2. マーカーが意図した位置に表示されない

#### 原因: [Y, X] の順序を間違えている

```typescript
// ❌ 間違い（幅, 高さ）
position={[imgWidth / 2, imgHeight / 2]}

// ✅ 正しい（高さ, 幅）
position={[imgHeight / 2, imgWidth / 2]}
```

**対策**: 変数名で明示する

```typescript
const markerY = imgHeight / 2;
const markerX = imgWidth / 2;
position={[markerY, markerX]}
```

---

### 6-3. 画像の外に空白が見える

#### 原因: maxBounds または maxBoundsViscosity の設定ミス

```typescript
// ✅ 正しい設定
maxBounds={bounds}
maxBoundsViscosity={1.0}  // または 0.5-0.8
```

---

## 7. 実装のベストプラクティス

### 7-1. 座標の管理

```typescript
// 定数を先に定義
const imgWidth = 1170;
const imgHeight = 696;

// bounds を再利用
const bounds: LatLngBoundsExpression = [
    [0, 0],
    [imgHeight, imgWidth],
];

// マーカー位置も計算で定義
const centerY = imgHeight / 2;
const centerX = imgWidth / 2;
```

---

### 7-2. アイコンの一元管理

```typescript
// icons.ts
import L from "leaflet";

export const icons = {
    entrance: L.icon({
        iconUrl: "/icons/entrance.png",
        iconSize: [48, 48],
        iconAnchor: [24, 24],
    }),
    library: L.icon({
        iconUrl: "/icons/library.png",
        iconSize: [48, 48],
        iconAnchor: [24, 24],
    }),
};
```

---

### 7-3. イベントハンドラの最適化

```typescript
// useCallback で再レンダリングを防ぐ
const handleMarkerClick = useCallback(
    // 引数はここ
    (place: string) => (): void => {
        // ここにクリック処理
    },
    [] // 依存配列が空 = 一度だけ生成
);
```

---

---

## 8. まとめ

### React-Leaflet が適している用途

✅ 自前の画像を地図として表示したい  
✅ シンプルなインタラクティブマップが必要  
✅ 軽量なライブラリを使いたい

### 押さえるべきポイント

1. **Next.js では `dynamic` + `ssr: false` が必須**
2. **座標は `[Y, X]` の順序**
3. **`CRS.Simple` でピクセル座標を使う**
4. **`maxBounds` で画像の外を隠す**
5. **`maxBoundsViscosity` で UX を調整**

### 参考リンク

-   [Leaflet 公式ドキュメント](https://leafletjs.com/)
-   [React-Leaflet 公式ドキュメント](https://react-leaflet.js.org/)
-   [Leaflet Tutorials](https://leafletjs.com/examples.html)

---

## 付録: 実装例

実際に動作するコードの完全版は、このリポジトリ内のページやコードを参照してください。

補足: アイコン等に使用しているあおるん（aorun）はマスコットキャラクターです。
</file>

<file path="README.md">
# Free-Space

仲間内で知識を共有するためのリポジトリです。

ライブラリのお試しや技術的に可能かどうかの検証も行います。

ここに書いてあるソースコード等は、フリーヒルズラボのメンバーであれば自由にコピーしていただいて構いません。

---

## 概要

### リポジトリのセットアップ

```bash
git clone https://github.com/takahiro-hirano67/Free-Space.git
cd frontend
npm install
cd ../
npm run dev
```

（下記のパッケージインストールコマンドは、別プロジェクトで利用する際の参考用）

---

### 新しいページを作成したい時について

新しいページを作成したい時は、Next App Router のディレクトリ構成に基づき
`frontend/app/home/〇〇/page.tsx` に記述するだけで既存コードに影響を与えず実装可能です。
お気軽にお試しください。

---

### backend ディレクトリについて

将来的に python でも同様に検証を行う可能性も考慮し、ディレクトリのみ作成しています。（今は中身なし）

---

## インストールしているライブラリについて

プロジェクト作成後に `npm install 〇〇` とインストールしたライブラリ記述していきます。
（都度追記）

明示的にライブラリ別で 1 行ずつ記述しています。
（分かりやすいよう一括インストールコマンドは避けています）

---

### 地図ライブラリ

#### Leaflet

Web ブラウザ上で動作する軽量なオープンソースの JavaScript ライブラリ

ズーム、パン、マーカー、ポリゴン、ポップアップなどの基本的な地図操作をシンプルに実装できる

##### インストールコマンド

```bash
npm install leaflet
npm install react-leaflet
npm install -D @types/leaflet
```

---

### アイコンライブラリ

#### Lucide-React

オープンソースアイコンライブラリで、1000 種類以上の軽量な SVG アイコンを提供し、カスタマイズが容易。

##### インストールコマンド

```bash
npm install lucide-react
```

---

### Markdown 表示関連

#### React-Markdown

React で Markdown（# 見出し や **太字** などの記法）を HTML として表示するための
React コンポーネント／ライブラリで、ブログやドキュメントビューア、
リアルタイムプレビュー付きエディタによく使われる。

-   **Markdown の解析（Remark）**
-   **HTML への変換（Rehype）**
-   **描画（React Components）**

##### インストールコマンド

```bash
npm install react-markdown
```

---

#### 関連プラグイン等

| カテゴリ            | プラグイン / ライブラリ         | 説明                                                                                                                                                             |
| ------------------- | ------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 機能の拡張          | remark-gfm                      | GitHub Flavored Markdown に対応させるプラグイン。標準の Markdown にはない「表（テーブル）」「打ち消し線」などが利用可能。                                        |
| 機能の拡張          | remark-breaks                   | 標準の Markdown では行末にスペース 2 つが必要な改行を、Enter キーでの改行をそのまま `<br>` タグとして扱えるようにする。                                          |
| 機能の拡張          | remark-github-blockquote-alert  | GitHub で採用されている `> [!NOTE]` や `> [!WARNING]` といった記述を表示できるようにする。                                                                       |
| 数式の表示          | remark-math                     | Markdown 内の `$E=mc^2$` や `$$...$$` といった数式記法を認識させるためのプラグイン。                                                                             |
| 数式の表示          | rehype-katex                    | `remark-math` で認識された数式を、KaTeX ライブラリを使ってブラウザ上で綺麗に表示できる HTML/CSS に変換する。                                                     |
| コードと図の描画    | react-syntax-highlighter        | コードブロック内のコードを、言語に合わせてシンタックスハイライト表示するライブラリ。                                                                             |
| コードと図の描画    | mermaid                         | テキストベースでフローチャートなどの図を描画できるライブラリ。                                                                                                   |
| コードと図の描画    | @types/react-syntax-highlighter | `react-syntax-highlighter` を TypeScript 環境で使用するための型定義ファイル（開発時のみ使用）。                                                                  |
| HTML の直接埋め込み | rehype-raw                      | Markdown 内に記述された生の HTML タグを、そのまま HTML として出力できるようにする（※XSS などのセキュリティリスクに注意が必要。信頼できるコンテンツでのみ使用）。 |

(XSS: クロスサイトスクリプティング)

##### インストールコマンド

```bash
npm install mermaid
npm install rehype-katex
npm install rehype-raw
npm install remark-breaks
npm install remark-gfm
npm install remark-github-blockquote-alert
npm install remark-math
npm install react-syntax-highlighter
npm i --save-dev @types/react-syntax-highlighter
```

---

## ディレクトリ構造

```
Free-Space
├─ backend
│  ├─ .python-version
│  ├─ main.py
│  └─ pyproject.toml
├─ frontend
│  ├─ app
│  │  ├─ favicon.ico
│  │  ├─ globals.css
│  │  ├─ home
│  │  │  ├─ HomeClient.tsx
│  │  │  ├─ maps
│  │  │  │  ├─ map-basic
│  │  │  │  │  ├─ MapView.tsx
│  │  │  │  │  ├─ MapWrapper.tsx
│  │  │  │  │  └─ page.tsx
│  │  │  │  ├─ map-floor
│  │  │  │  │  ├─ MapView.tsx
│  │  │  │  │  ├─ MapWrapper.tsx
│  │  │  │  │  └─ page.tsx
│  │  │  │  ├─ map-pin
│  │  │  │  │  ├─ DirectionPad.tsx
│  │  │  │  │  ├─ MapView.tsx
│  │  │  │  │  ├─ MapWrapper.tsx
│  │  │  │  │  └─ page.tsx
│  │  │  │  └─ map-zoom
│  │  │  │     ├─ MapView.tsx
│  │  │  │     ├─ MapWrapper.tsx
│  │  │  │     └─ page.tsx
│  │  │  └─ page.tsx
│  │  ├─ layout.tsx
│  │  └─ page.tsx
│  ├─ components
│  │  ├─ layout
│  │  │  └─ header.tsx
│  │  ├─ markdown
│  │  │  ├─ MarkdownViewer.tsx
│  │  │  ├─ markdown_style.css
│  │  │  └─ Mermaid.tsx
│  │  └─ ui
│  │     └─ CopyButton.tsx
│  ├─ eslint.config.mjs
│  ├─ hooks
│  │  └─ useMarkdown.ts
│  ├─ next.config.ts
│  ├─ package-lock.json
│  ├─ package.json
│  ├─ postcss.config.mjs
│  ├─ public
│  │  ├─ docs
│  │  │  └─ maps
│  │  │     └─ React-Leaflet-Guide.md
│  │  ├─ maps
│  │  │  ├─ icons
│  │  │  │  └─ soccer_ball.png
│  │  │  └─ map
│  │  │     ├─ campus_map.jpg
│  │  │     ├─ campus_map_ziyuu.png
│  │  │     ├─ ziyuu_floor_1.png
│  │  │     ├─ ziyuu_floor_2.png
│  │  │     ├─ ziyuu_floor_3.png
│  │  │     └─ ziyuu_floor_4.png
│  │  └─ mascot
│  │     ├─ aorun_feel_down.png
│  │     ├─ aorun_feel_up.png
│  │     ├─ aorun_normal.png
│  │     └─ aorun_question.png
│  ├─ tailwind.config.js
│  └─ tsconfig.json
├─ README.md
├─ repomix-output.xml
└─ repomix.config.json

```
</file>

</files>
